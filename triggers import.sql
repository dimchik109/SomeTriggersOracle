SET SQLBLANKLINES ON;
SET DEFINE OFF;
ALTER SESSION SET NLS_DATE_FORMAT = 'MM/DD/SYYYY HH24:MI:SS';
ALTER SESSION SET NLS_TIMESTAMP_TZ_FORMAT = 'MM/DD/SYYYY HH24:MI:SS.FF TZH:TZM';
ALTER SESSION SET NLS_TIMESTAMP_FORMAT = 'MM/DD/SYYYY HH24:MI:SS.FF';
ALTER SESSION SET NLS_NUMERIC_CHARACTERS = '.,';
ALTER SESSION SET NLS_NCHAR_CONV_EXCP = FALSE;
ALTER SESSION SET TIME_ZONE = '+03:00';

--
-- Создать триггер "PMAC"."TRG_USERS_ID"
--
CREATE TRIGGER PMAC.TRG_USERS_ID
  BEFORE INSERT
  ON PMAC.TAB_USERS
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID.NEXTVAL
    INTO :new.ID_USER
    FROM dual;
END;
/

--
-- Создать триггер "PMAC"."TRG_UPDATE_DATE"
--
CREATE TRIGGER PMAC.TRG_UPDATE_DATE
  BEFORE INSERT OR UPDATE
  ON PMAC.TAB_OPERATION
  FOR EACH ROW
BEGIN
  :new.DATE_UPDATE := SYSDATE;
END;
/

--
-- Создать триггер "PMAC"."TRG_UPDATE_DATA"
--
CREATE TRIGGER PMAC.TRG_UPDATE_DATA
  AFTER UPDATE OF ID, ID_OPERATION, ID_PRODUCT, ID_COMPANY, DATE_CREATE, CC, ID_PRICE, DISCOUNT, QTY, COURSE
  ON PMAC.TAB_OPERATION_PRODUCT
  FOR EACH ROW
BEGIN
  UPDATE TAB_OPERATION O
    SET DATE_UPDATE = SYSDATE
    WHERE O.ID_OPERATION = ID_OPERATION;
END;
/

--
-- Создать триггер "PMAC"."TRG_UPDATE_COURSE"
--
CREATE TRIGGER PMAC.TRG_UPDATE_COURSE
  BEFORE INSERT OR UPDATE
  ON PMAC.TAB_OPERATION_MAG
  FOR EACH ROW
BEGIN
  SELECT TCR.ID_COURSE
    INTO :NEW.ID_COURSE
    FROM TAB_COURSE TCR
    WHERE TCR.DATE_ADD = (SELECT MAX(TCR1.DATE_ADD)
          FROM TAB_COURSE TCR1);
END;
/

--
-- Создать триггер "PMAC"."TRG_TERMINAL_MAG"
--
CREATE TRIGGER PMAC.TRG_TERMINAL_MAG
  BEFORE INSERT
  ON PMAC.TAB_CASHLESS
  FOR EACH ROW
BEGIN
  SELECT SEQ_TERMINAL_MAG.NEXTVAL
    INTO :new.TERMINAL
    FROM dual;
END;
/

--
-- Создать триггер "PMAC"."TRG_ROLE_ID"
--
CREATE TRIGGER PMAC.TRG_ROLE_ID
  BEFORE INSERT
  ON PMAC.TAB_ROLE
  FOR EACH ROW
BEGIN
  SELECT MAX(TR.ID_ROLE) + 1
    INTO :new.ID_ROLE
    FROM TAB_ROLE TR;
END;
/

--
-- Создать триггер "PMAC"."TRG_PRODUCT_AFTER"
--
CREATE TRIGGER PMAC.TRG_PRODUCT_AFTER
  AFTER INSERT
  ON PMAC.TAB_PRODUCT
  FOR EACH ROW
DECLARE
  PROOF NUMBER;
BEGIN
  INSERT INTO TAB_IMAGE (
    ID_PRODUCT, IMAGE, IMAGE_NUMBER
  )
  VALUES (:new.ID_PRODUCT, NULL, 1);

  INSERT INTO TAB_SKID (
    ID_PRODUCT
  )

  VALUES (:new.ID_PRODUCT);


  INSERT INTO TAB_SKID_MAG (
    ID_PRODUCT, ID_COMPANY
  )
  SELECT :new.ID_PRODUCT, tc.ID_COMPANY
  FROM TAB_COMPANY tc
  WHERE TC.ID_TAB_TYPE = 4;


  SELECT NVL2(MAX(TG.ID_GROUP), 1, 0)
    INTO PROOF
    FROM TAB_GROUP_SAB TGS
      JOIN TAB_GROUP TG
        ON TGS.ID_GROUP_SAB = TG.ID_GROUP_SAB
    WHERE TG.ID_GROUP = :NEW.ID_GROUP
      AND TGS.ID_GROUP_SAB = 70;

  IF PROOF = 1
  THEN
    INSERT INTO TAB_ACCESSORY (
      ID_TAB_PRODUCT
    )
    VALUES (:NEW.ID_PRODUCT);
  END IF;


END;
/

--
-- Создать триггер "PMAC"."TRG_PAYMENTS_DATE"
--
CREATE TRIGGER PMAC.TRG_PAYMENTS_DATE
  BEFORE UPDATE OF CLOSED
  ON PMAC.TAB_PAYMENTS
  FOR EACH ROW
BEGIN
  IF :NEW.CLOSED = 1
    AND :OLD.CLOSED = 0
  THEN
    :NEW.DATE_CLOSED := SYSDATE;
    :NEW.DATE_PAYMENTS := SYSDATE;
  END IF;
  IF :NEW.CLOSED = 0
  THEN
    :NEW.DATE_CREATE := SYSDATE;
  END IF;
END;
/

--
-- Создать триггер "PMAC"."TRG_OPERATION_STORAGE"
--
CREATE TRIGGER PMAC.TRG_OPERATION_STORAGE
  AFTER UPDATE OF STATUS
  ON PMAC.TAB_OPERATION
  FOR EACH ROW
BEGIN
  IF :OLD.STATUS = 20
    AND :NEW.STATUS = 21
  THEN
    INSERT INTO TAB_OPERATION_STORAGE (
      ID_OPERATION, ID_STORAGE
    )
    SELECT TOP.ID_OPERATION,
    TOP.ID_COMPANY
    FROM TAB_OPERATION_PRODUCT TOP
    WHERE TOP.ID_OPERATION = :OLD.ID_OPERATION
    GROUP BY TOP.ID_COMPANY,
    TOP.ID_OPERATION;
  END IF;

  IF :OLD.STATUS IN (21, 22)
    AND :NEW.STATUS = 20
  THEN
    DELETE FROM TAB_OPERATION_STORAGE
      WHERE ID_OPERATION = :OLD.ID_OPERATION;
  END IF;

  IF :NEW.STATUS = 13
  THEN
    INSERT INTO TAB_OPERATION_STORAGE (
      ID_OPERATION, ID_STORAGE
    )
    SELECT TOP.ID_OPERATION,
    TOP.ID_COMPANY
    FROM TAB_OPERATION_PRODUCT TOP
    WHERE TOP.ID_OPERATION = :OLD.ID_OPERATION
    GROUP BY TOP.ID_COMPANY,
    TOP.ID_OPERATION;
  END IF;


-- PRC_RESERVE(:OLD.ID_OPERATION);

END;
/

--
-- Создать триггер "PMAC"."TRG_OPERATION_PRODUCT_STIM"
--
CREATE TRIGGER PMAC.TRG_OPERATION_PRODUCT_STIM
  AFTER INSERT OR UPDATE OR DELETE
  ON PMAC.TAB_OPERATION_PRODUCT
  FOR EACH ROW
DECLARE
  type_oper NUMBER;
  STIMUL    NUMBER;

BEGIN
  IF INSERTING
  THEN
    SELECT O.OPERATION_ID_TYPE
      INTO TYPE_OPER
      FROM TAB_OPERATION O
      WHERE O.ID_OPERATION = :NEW.ID_operation;
  END IF;

  IF DELETING
  THEN
    SELECT O.OPERATION_ID_TYPE
      INTO TYPE_OPER
      FROM TAB_OPERATION O
      WHERE O.ID_OPERATION = :OLD.ID_operation;
  END IF;

  IF TYPE_OPER = 3
  THEN
    BEGIN

      IF INSERTING
      THEN
        INSERT INTO TAB_STIMULATION_PAYOUT tsp (
          tsp.ID_OPERATION, tsp.ID_PRODUCT
        )
        VALUES (:new.ID_OPERATION, :NEW.ID_PRODUCT);
      END IF;

      IF DELETING
      THEN
        DELETE TAB_STIMULATION_PAYOUT
          WHERE ID_PRODUCT = :OLD.ID_PRODUCT
            AND ID_OPERATION = :OLD.ID_OPERATION;
      END IF;
    END;
  END IF;
END;
/

--
-- Создать триггер "PMAC"."TRG_OPERATION_PRODUCT"
--
CREATE TRIGGER PMAC.TRG_OPERATION_PRODUCT
  BEFORE INSERT
  ON PMAC.TAB_OPERATION_PRODUCT
  FOR EACH ROW
BEGIN
  SELECT TP.CC
    INTO :NEW.CC
    FROM tab_product TP
    WHERE TP.ID_PRODUCT = :NEW.ID_PRODUCT;

  IF :NEW.COURSE IS NULL
  THEN
    SELECT TC.COURSE
      INTO :NEW.COURSE
      FROM TAB_COURSE TC
      WHERE TC.COURSE_TYPE = 1
        AND TC.DATE_ADD = (SELECT MAX(TC.DATE_ADD)
            FROM TAB_COURSE TC
            WHERE TC.COURSE_TYPE = 1);

  END IF;

  SELECT ROUND(DECODE(:NEW.ID_PRICE, 1, VR.KO, 2, VR.OP, 3, VR.MO, 4, VR.MRRC, 5, VR.MRRC) * (1 - :NEW.DISCOUNT * 0.01), 2)
    INTO :NEW.PRICE
    FROM VIE_RESIDUES VR
    WHERE VR.ID_PRODUCT = :NEW.ID_PRODUCT;



END;
/

--
-- Создать триггер "PMAC"."TRG_OPERATION_PAYMENTS"
--
CREATE TRIGGER PMAC.TRG_OPERATION_PAYMENTS
  BEFORE INSERT OR UPDATE OR DELETE
  ON PMAC.TAB_OPERATION
  FOR EACH ROW
BEGIN
  IF UPDATING
    AND :OLD.STATUS = 22
    AND :NEW.STATUS <> 22
  THEN
    DELETE TAB_OPERATION_MAG
      WHERE ID_OPERATION = :OLD.ID_OPERATION;
    DELETE TAB_CASHLESS
      WHERE ID_OPERATION = :OLD.ID_OPERATION;
  END IF;
  IF DELETING
  THEN
    DELETE TAB_OPERATION_MAG
      WHERE ID_OPERATION = :OLD.ID_OPERATION;
    DELETE TAB_CASHLESS
      WHERE ID_OPERATION = :OLD.ID_OPERATION;
  END IF;
END;
/

--
-- Создать триггер "PMAC"."TRG_OPERATION_PAID"
--
CREATE TRIGGER PMAC.TRG_OPERATION_PAID
  FOR UPDATE
  ON PMAC.TAB_OPERATION
COMPOUND TRIGGER
  VAR_ID_COMPANY          NUMBER;
  VAR_CASH_USD            NUMBER;
  VAR_PRICE               NUMBER;
  VAR_SUM_PRICE_OPERATION NUMBER;
  VAR_ID_OPERATION        NUMBER;
  VAR_ID_PAYMENT          NUMBER;
  VAR_LAST_ID_OPERATION   NUMBER;
  VAR_LAST_ID_PAYMENT     NUMBER;
  VAR_UPDATING            BOOLEAN;
  VAR_SUM_PRIHOD          NUMBER;
  VAR_ID_PRIHOD           NUMBER;
  VAR_STATUS              NUMBER;

BEFORE EACH ROW IS BEGIN
  IF (:NEW.STATUS = 22
    AND :OLD.STATUS = 21)
  THEN
    VAR_ID_COMPANY := :NEW.ID_COMPANY;
    VAR_STATUS := :NEW.STATUS;
    VAR_ID_OPERATION := :NEW.ID_OPERATION;
  END IF;
  IF
    (:NEW.STATUS = 14)
  THEN
    VAR_ID_PRIHOD := :NEW.ID_OPERATION;
    VAR_ID_COMPANY := :NEW.ID_COMPANY;
    VAR_STATUS := :NEW.STATUS;
    VAR_ID_OPERATION := :NEW.ID_OPERATION;
  END IF;

  IF (:NEW.STATUS = 41
    AND :OLD.STATUS = 40)
  THEN
    VAR_ID_COMPANY := :NEW.ID_COMPANY;
    VAR_STATUS := :NEW.STATUS;
    VAR_ID_OPERATION := :NEW.ID_OPERATION;
  END IF;


END BEFORE EACH ROW;

AFTER STATEMENT IS
BEGIN


  IF VAR_ID_COMPANY IS NOT NULL
  THEN

    --Узнаем баланс проплат
    SELECT MAX(ROUND(NVL(SUM(TP1.CASH_USD) - PROPLACHINUE.PRICE + VOZVRATI.PRICE, 0), 2))
      INTO VAR_CASH_USD
      FROM TAB_PAYMENTS TP1,
           (SELECT NVL(SUM(TOP.PRICE * TOP.QTY * DECODE(TOP.DISCOUNT, 0, 1, TOP.DISCOUNT * 0.01)), 0) PRICE
               FROM TAB_OPERATION OP
                 JOIN TAB_OPERATION_PRODUCT TOP
                   ON OP.ID_OPERATION = TOP.ID_OPERATION
                 JOIN TAB_PAID TP
                   ON TP.ID_OPERATION = OP.ID_OPERATION
               WHERE OP.ID_COMPANY = VAR_ID_COMPANY) PROPLACHINUE,
           (SELECT NVL(SUM(TOP.PRICE), 0) PRICE
               FROM TAB_OPERATION_PRODUCT TOP
                 JOIN TAB_OPERATION OP
                   ON OP.ID_OPERATION = TOP.ID_OPERATION
               WHERE OP.OPERATION_ID_TYPE = 0
                 AND OP.ID_COMPANY = VAR_ID_COMPANY) VOZVRATI
      WHERE TP1.ID_COMPANY = VAR_ID_COMPANY
      GROUP BY PROPLACHINUE.PRICE,
               VOZVRATI.PRICE;

    --Узнаем сумму счета 
    SELECT NVL(SUM(TOP.PRICE * TOP.QTY * DECODE(TOP.DISCOUNT, 0, 1, TOP.DISCOUNT * 0.01)), 0)
      INTO VAR_SUM_PRICE_OPERATION
      FROM TAB_OPERATION OP
        JOIN TAB_OPERATION_PRODUCT TOP
          ON OP.ID_OPERATION = TOP.ID_OPERATION
      WHERE OP.OPERATION_DATE = (SELECT MIN(OP1.OPERATION_DATE)
            FROM TAB_OPERATION OP1
              LEFT JOIN TAB_PAID TP
                ON TP.ID_OPERATION = OP1.ID_OPERATION
              JOIN TAB_COMPANY TC
                ON OP1.ID_COMPANY = TC.ID_COMPANY
            WHERE OP1.ID_COMPANY = VAR_ID_COMPANY
              AND TP.ID_OPERATION IS NULL
              AND (OP1.STATUS = 22
              AND TC.ID_TAB_TYPE IN (1, 5, 8)
              OR OP1.STATUS = 41
              AND TC.ID_TAB_TYPE IN (3, 6)))
        AND OP.ID_COMPANY = VAR_ID_COMPANY;

    --Узнаем ид последней проплаты
    SELECT MAX(TP.ID)
      INTO VAR_LAST_ID_PAYMENT
      FROM TAB_PAYMENTS TP
      WHERE TP.ID_COMPANY = VAR_ID_COMPANY
        AND TP.DATE_PAYMENTS = (SELECT MAX(TP1.DATE_PAYMENTS)
            FROM TAB_PAYMENTS TP1)
        AND TP.CLOSED = 1;

    --Узнаем ид последнего незакрытого счета
    SELECT MAX(OP.ID_OPERATION)
      INTO VAR_LAST_ID_OPERATION
      FROM TAB_OPERATION OP
      WHERE OP.OPERATION_DATE = (SELECT MIN(OP1.OPERATION_DATE)
            FROM TAB_OPERATION OP1
              LEFT JOIN TAB_PAID TP
                ON TP.ID_OPERATION = OP1.ID_OPERATION
              JOIN TAB_COMPANY TC
                ON OP1.ID_COMPANY = TC.ID_COMPANY
            WHERE OP1.ID_COMPANY = VAR_ID_COMPANY
              AND TP.ID_OPERATION IS NULL
              AND (OP1.STATUS = 22
              AND TC.ID_TAB_TYPE IN (1, 5, 8)
              OR OP1.STATUS = 41
              AND TC.ID_TAB_TYPE IN (3, 6)))
        AND OP.ID_COMPANY = VAR_ID_COMPANY;

    --Узнаем сумму прихода
    SELECT NVL(SUM(TOP.PRICE), 0)
      INTO VAR_SUM_PRIHOD
      FROM TAB_OPERATION OP
        JOIN TAB_OPERATION_PRODUCT TOP
          ON OP.ID_OPERATION = TOP.ID_OPERATION
      WHERE OP.OPERATION_DATE = (SELECT MIN(OP1.OPERATION_DATE)
            FROM TAB_OPERATION OP1
              LEFT JOIN TAB_PAID TP
                ON TP.ID_OPERATION = OP1.ID_OPERATION
            WHERE OP1.ID_COMPANY = VAR_ID_COMPANY
              AND TP.ID_OPERATION IS NULL
              AND OP1.STATUS = 14)
        AND OP.ID_COMPANY = VAR_ID_COMPANY;

    IF VAR_CASH_USD >= VAR_SUM_PRICE_OPERATION
    THEN

      INSERT INTO TAB_PAID (
        ID_OPERATION, ID_CATEGORY, DATE_PAYMENT, ID_PAYMENT
      )
      VALUES (VAR_LAST_ID_OPERATION, 4, SYSDATE, CASE VAR_STATUS WHEN 22 THEN VAR_LAST_ID_PAYMENT WHEN 14 THEN VAR_ID_PRIHOD END);

    END IF;
  END IF;



END AFTER STATEMENT;
END;
/

--
-- Создать триггер "PMAC"."TRG_OPERATION_MAG"
--
CREATE TRIGGER PMAC.TRG_OPERATION_MAG
  BEFORE INSERT OR UPDATE OR DELETE
  ON PMAC.TAB_OPERATION
  FOR EACH ROW
BEGIN
  IF UPDATING
    AND :OLD.STATUS = 22
    AND :NEW.STATUS <> 22
  THEN
    DELETE TAB_OPERATION_MAG
      WHERE ID_OPERATION = :OLD.ID_OPERATION;
    DELETE TAB_CASHLESS
      WHERE ID_OPERATION = :OLD.ID_OPERATION;
  END IF;
  IF DELETING
  THEN
    DELETE TAB_OPERATION_MAG
      WHERE ID_OPERATION = :OLD.ID_OPERATION;
    DELETE TAB_CASHLESS
      WHERE ID_OPERATION = :OLD.ID_OPERATION;
  END IF;
END;
/

--
-- Создать триггер "PMAC"."TRG_OPERATION_CHECK"
--
CREATE TRIGGER PMAC.TRG_OPERATION_CHECK
  FOR UPDATE
  ON PMAC.TAB_OPERATION_STORAGE
COMPOUND TRIGGER
  VAR_CHEKING      NUMBER;
  VAR_ID_OPERATION NUMBER;
  VAR_STATUS       NUMBER;

BEFORE EACH ROW IS BEGIN
  IF :NEW.CHEK = 1
  THEN
    VAR_ID_OPERATION := :NEW.ID_OPERATION;

  END IF;
END BEFORE EACH ROW;

AFTER STATEMENT IS
BEGIN

  IF (VAR_ID_OPERATION IS NOT NULL)
  THEN

    SELECT MIN(TOS.CHEK)
      INTO VAR_CHEKING
      FROM TAB_OPERATION_STORAGE TOS
      WHERE TOS.ID_OPERATION = VAR_ID_OPERATION
      GROUP BY TOS.ID_OPERATION;

    SELECT O.STATUS
      INTO VAR_STATUS
      FROM TAB_OPERATION O
      WHERE O.ID_OPERATION = VAR_ID_OPERATION;


    IF (VAR_CHEKING = 1)
      AND (VAR_STATUS = 21)
    THEN
      UPDATE TAB_OPERATION O
        SET STATUS = 22
        WHERE O.ID_OPERATION = VAR_ID_OPERATION;
    END IF;
    IF (VAR_CHEKING = 1)
      AND (VAR_STATUS = 13)
    THEN
      UPDATE TAB_OPERATION O
        SET STATUS = 14
        WHERE O.ID_OPERATION = VAR_ID_OPERATION;
    END IF;
  END IF;



END AFTER STATEMENT;
END;
/

--
-- Создать триггер "PMAC"."TRG_LOGON"
--
CREATE TRIGGER PMAC.TRG_LOGON
  AFTER LOGON
    ON DATABASE
BEGIN
  EXECUTE IMMEDIATE 'ALTER SESSION SET CURRENT_SCHEMA = PMAC';
EXCEPTION
  WHEN OTHERS THEN NULL; -- prevent a login failure due to an exception
END logon_trg;
/

--
-- Создать триггер "PMAC"."TRG_ID_SPARE"
--
CREATE TRIGGER PMAC.TRG_ID_SPARE
  BEFORE INSERT
  ON PMAC.TAB_SPARE
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_SPARE.NEXTVAL
    INTO :new.ID_SPARE
    FROM dual;
END;
/

--
-- Создать триггер "PMAC"."TRG_ID_SELLER_CATEGORY"
--
CREATE TRIGGER PMAC.TRG_ID_SELLER_CATEGORY
  BEFORE INSERT
  ON PMAC.TAB_SELLER_CATEGORY
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_SELLER_CATEGORY.NEXTVAL
    INTO :new.ID_CATEGORY
    FROM dual;
END;
/

ALTER TRIGGER PMAC.TRG_ID_SELLER_CATEGORY DISABLE;
/

--
-- Создать триггер "PMAC"."TRG_ID_SELLER"
--
CREATE TRIGGER PMAC.TRG_ID_SELLER
  BEFORE INSERT
  ON PMAC.TAB_SELLER
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_SELLER.NEXTVAL
    INTO :new.ID_SELLER
    FROM dual;
END;
/

--
-- Создать триггер "PMAC"."TRG_ID_PRODUCT_ORDER_ITEMS"
--
CREATE TRIGGER PMAC.TRG_ID_PRODUCT_ORDER_ITEMS
  BEFORE INSERT
  ON PMAC.TAB_ORDER_ITEMS
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_PRODUCT_ORDER_ITEMS.NEXTVAL
    INTO :new.ORDER_ITEMS_ID
    FROM DUAL D;

  INSERT INTO TAB_IMAGE_ORDER_ITEMS (
    ORDER_ITEMS_ID, IMAGE, IMAGE_NUMBER
  )
  VALUES (:new.ORDER_ITEMS_ID, NULL, 1);
END;
/

--
-- Создать триггер "PMAC"."TRG_ID_PRODUCT"
--
CREATE TRIGGER PMAC.TRG_ID_PRODUCT
  BEFORE INSERT
  ON PMAC.TAB_PRODUCT
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_PRODUCT_ORDER_ITEMS.NEXTVAL
    INTO :new.ID_PRODUCT
    FROM DUAL D;


END;
/

--
-- Создать триггер "PMAC"."TRG_ID_PERIOD_BANK"
--
CREATE TRIGGER PMAC.TRG_ID_PERIOD_BANK
  BEFORE INSERT
  ON PMAC.TAB_SETTING_PERIOD_BANK
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_PERIOD_BANK.NEXTVAL
    INTO :new.ID
    FROM DUAL D;
END;
/

--
-- Создать триггер "PMAC"."TRG_ID_PAYMENTS"
--
CREATE TRIGGER PMAC.TRG_ID_PAYMENTS
  BEFORE INSERT
  ON PMAC.TAB_PAYMENTS
  FOR EACH ROW
BEGIN
  SELECT SEQ_OPERATION_PAYMENTS.NEXTVAL
    INTO :new.ID
    FROM dual;
END;
/

--
-- Создать триггер "PMAC"."TRG_ID_OPERATION"
--
CREATE TRIGGER PMAC.TRG_ID_OPERATION
  BEFORE INSERT
  ON PMAC.TAB_OPERATION
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_OPERATION.NEXTVAL
    INTO :new.ID_OPERATION
    FROM DUAL D;
END;
/

--
-- Создать триггер "PMAC"."TRG_ID_COST_TYPE"
--
CREATE TRIGGER PMAC.TRG_ID_COST_TYPE
  BEFORE INSERT
  ON PMAC.TAB_COST_TYPE
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_COST_TYPE.NEXTVAL
    INTO :new.ID_TYPE
    FROM dual;
END;
/

--
-- Создать триггер "PMAC"."TRG_ID_COST_OPERATION_MAG"
--
CREATE TRIGGER PMAC.TRG_ID_COST_OPERATION_MAG
  BEFORE INSERT
  ON PMAC.TAB_OPERATION_MAG
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_COST_OPERATION_MAG.NEXTVAL
    INTO :new.ID_COST
    FROM dual;
END;
/

--
-- Создать триггер "PMAC"."TRG_ID_COST_MAG_TYPE"
--
CREATE TRIGGER PMAC.TRG_ID_COST_MAG_TYPE
  BEFORE INSERT
  ON PMAC.TAB_COST_MAG_TYPE
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_COST_MAG_TYPE.NEXTVAL
    INTO :new.ID_TYPE
    FROM dual;
END;
/

--
-- Создать триггер "PMAC"."TRG_ID_COST_CASHLESS"
--
CREATE TRIGGER PMAC.TRG_ID_COST_CASHLESS
  BEFORE INSERT
  ON PMAC.TAB_CASHLESS
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_COST_CASHLESS.NEXTVAL
    INTO :new.ID_COST
    FROM dual;
END;
/

--
-- Создать триггер "PMAC"."TRG_ID_COST"
--
CREATE TRIGGER PMAC.TRG_ID_COST
  BEFORE INSERT
  ON PMAC.TAB_COST
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_COST.NEXTVAL
    INTO :new.ID_COST
    FROM dual;
END;
/

--
-- Создать триггер "PMAC"."TRG_ID_CASHBOX"
--
CREATE TRIGGER PMAC.TRG_ID_CASHBOX
  BEFORE INSERT
  ON PMAC.TAB_CASHBOX
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_CASHBOX.NEXTVAL
    INTO :new.ID_CASHBOX
    FROM dual;
END;
/

--
-- Создать триггер "PMAC"."TRG_ID_ALGORITHM"
--
CREATE TRIGGER PMAC.TRG_ID_ALGORITHM
  BEFORE INSERT
  ON PMAC.TAB_ALGORITHM
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_ALGORITHM.nextval
    INTO :new.ID_ALGORITHM
    FROM DUAL D;
END;
/

--
-- Создать триггер "PMAC"."TRG_HISTORY_USERS_ON_ROLE"
--
CREATE TRIGGER PMAC.TRG_HISTORY_USERS_ON_ROLE
  AFTER INSERT OR UPDATE OR DELETE
  ON PMAC.TAB_USERS_ON_ROLE
  FOR EACH ROW
BEGIN
  IF INSERTING
  THEN
    INSERT INTO PMAC.HISTORY_USERS_ON_ROLE (
      ACTION, DATE_ACTION, USER_ACTION, NEW_ID_TAB_USER, NEW_ID_TAB_ROLE
    )
    VALUES ('INSERT', SYSDATE, USER, :NEW.ID_TAB_USER, :NEW.ID_TAB_ROLE);
  ELSIF UPDATING
  THEN
    INSERT INTO PMAC.HISTORY_USERS_ON_ROLE (
      OLD_ID_TAB_USER, OLD_ID_TAB_ROLE, ACTION, DATE_ACTION, USER_ACTION, NEW_ID_TAB_USER, NEW_ID_TAB_ROLE
    )
    VALUES (:OLD.ID_TAB_USER, :OLD.ID_TAB_ROLE, 'UPDATE', SYSDATE, USER, :NEW.ID_TAB_USER, :NEW.ID_TAB_ROLE);
  ELSIF DELETING
  THEN
    INSERT INTO PMAC.HISTORY_USERS_ON_ROLE (
      OLD_ID_TAB_USER, OLD_ID_TAB_ROLE, ACTION, DATE_ACTION, USER_ACTION
    )
    VALUES (:OLD.ID_TAB_USER, :OLD.ID_TAB_ROLE, 'DELETE', SYSDATE, USER);
  END IF;
END;
/

ALTER TRIGGER PMAC.TRG_HISTORY_USERS_ON_ROLE DISABLE;
/

--
-- Создать триггер "PMAC"."TRG_HISTORY_USERS_ON_MANAGERS"
--
CREATE TRIGGER PMAC.TRG_HISTORY_USERS_ON_MANAGERS
  AFTER INSERT OR UPDATE OR DELETE
  ON PMAC.TAB_USERS_ON_MANAGERS
  FOR EACH ROW
BEGIN
  IF INSERTING
  THEN
    INSERT INTO PMAC.HISTORY_USERS_ON_MANAGERS (
      ACTION, DATE_ACTION, USER_ACTION, NEW_ID_TAB_MANAGERS, NEW_ID_TAB_USER
    )
    VALUES ('INSERT', SYSDATE, USER, :NEW.ID_TAB_MANAGERS, :NEW.ID_TAB_USER);
  ELSIF UPDATING
  THEN
    INSERT INTO PMAC.HISTORY_USERS_ON_MANAGERS (
      OLD_ID_TAB_MANAGERS, OLD_ID_TAB_USER, ACTION, DATE_ACTION, USER_ACTION, NEW_ID_TAB_MANAGERS, NEW_ID_TAB_USER
    )
    VALUES (:OLD.ID_TAB_MANAGERS, :OLD.ID_TAB_USER, 'UPDATE', SYSDATE, USER, :NEW.ID_TAB_MANAGERS, :NEW.ID_TAB_USER);
  ELSIF DELETING
  THEN
    INSERT INTO PMAC.HISTORY_USERS_ON_MANAGERS (
      OLD_ID_TAB_MANAGERS, OLD_ID_TAB_USER, ACTION, DATE_ACTION, USER_ACTION
    )
    VALUES (:OLD.ID_TAB_MANAGERS, :OLD.ID_TAB_USER, 'DELETE', SYSDATE, USER);
  END IF;
END;
/

ALTER TRIGGER PMAC.TRG_HISTORY_USERS_ON_MANAGERS DISABLE;
/

--
-- Создать триггер "PMAC"."TRG_HISTORY_USERS"
--
CREATE TRIGGER PMAC.TRG_HISTORY_USERS
  AFTER INSERT OR UPDATE OR DELETE
  ON PMAC.TAB_USERS
  FOR EACH ROW
BEGIN
  IF INSERTING
  THEN
    INSERT INTO PMAC.HISTORY_USERS (
      ACTION, DATE_ACTION, USER_ACTION, NEW_ID_USER, NEW_NAME, NEW_PASSWORD
    )
    VALUES ('INSERT', SYSDATE, USER, :NEW.ID_USER, :NEW.NAME, :NEW.PASSWORD);
  ELSIF UPDATING
  THEN
    INSERT INTO PMAC.HISTORY_USERS (
      OLD_ID_USER, OLD_NAME, OLD_PASSWORD, ACTION, DATE_ACTION, USER_ACTION, NEW_ID_USER, NEW_NAME, NEW_PASSWORD
    )
    VALUES (:OLD.ID_USER, :OLD.NAME, :OLD.PASSWORD, 'UPDATE', SYSDATE, USER, :NEW.ID_USER, :NEW.NAME, :NEW.PASSWORD);
  ELSIF DELETING
  THEN
    INSERT INTO PMAC.HISTORY_USERS (
      OLD_ID_USER, OLD_NAME, OLD_PASSWORD, ACTION, DATE_ACTION, USER_ACTION
    )
    VALUES (:OLD.ID_USER, :OLD.NAME, :OLD.PASSWORD, 'DELETE', SYSDATE, USER);
  END IF;
END;
/

ALTER TRIGGER PMAC.TRG_HISTORY_USERS DISABLE;
/

--
-- Создать триггер "PMAC"."TRG_HISTORY_ROLE"
--
CREATE TRIGGER PMAC.TRG_HISTORY_ROLE
  AFTER INSERT OR UPDATE OR DELETE
  ON PMAC.TAB_ROLE
  FOR EACH ROW
BEGIN
  IF INSERTING
  THEN
    INSERT INTO PMAC.HISTORY_ROLE (
      ACTION, DATE_ACTION, USER_ACTION, NEW_ID_ROLE, NEW_ROLE, NEW_FORM, NEW_TAB_COMMENT
    )
    VALUES ('INSERT', SYSDATE, USER, :NEW.ID_ROLE, :NEW.ROLE, :NEW.FORM, :NEW.TAB_COMMENT);
  ELSIF UPDATING
  THEN
    INSERT INTO PMAC.HISTORY_ROLE (
      OLD_ID_ROLE, OLD_ROLE, OLD_FORM, OLD_TAB_COMMENT, ACTION, DATE_ACTION, USER_ACTION, NEW_ID_ROLE, NEW_ROLE, NEW_FORM, NEW_TAB_COMMENT
    )
    VALUES (:OLD.ID_ROLE, :OLD.ROLE, :OLD.FORM, :OLD.TAB_COMMENT, 'UPDATE', SYSDATE, USER, :NEW.ID_ROLE, :NEW.ROLE, :NEW.FORM, :NEW.TAB_COMMENT);
  ELSIF DELETING
  THEN
    INSERT INTO PMAC.HISTORY_ROLE (
      OLD_ID_ROLE, OLD_ROLE, OLD_FORM, OLD_TAB_COMMENT, ACTION, DATE_ACTION, USER_ACTION
    )
    VALUES (:OLD.ID_ROLE, :OLD.ROLE, :OLD.FORM, :OLD.TAB_COMMENT, 'DELETE', SYSDATE, USER);
  END IF;
END;
/

ALTER TRIGGER PMAC.TRG_HISTORY_ROLE DISABLE;
/

--
-- Создать триггер "PMAC"."TRG_HISTORY_GROUP_SAB"
--
CREATE TRIGGER PMAC.TRG_HISTORY_GROUP_SAB
  AFTER INSERT OR UPDATE OR DELETE
  ON PMAC.TAB_GROUP_SAB
  FOR EACH ROW
BEGIN
  IF INSERTING
  THEN
    INSERT INTO PMAC.HISTORY_GROUP_SAB (
      ACTION, DATE_ACTION, USER_ACTION, NEW_ID_GROUP_SAB, NEW_SAB_NAME, NEW_SORT
    )
    VALUES ('INSERT', SYSDATE, USER, :NEW.ID_GROUP_SAB, :NEW.SAB_NAME, :NEW.SORT);
  ELSIF UPDATING
  THEN
    INSERT INTO PMAC.HISTORY_GROUP_SAB (
      OLD_ID_GROUP_SAB, OLD_SAB_NAME, OLD_SORT, ACTION, DATE_ACTION, USER_ACTION, NEW_ID_GROUP_SAB, NEW_SAB_NAME, NEW_SORT
    )
    VALUES (:OLD.ID_GROUP_SAB, :OLD.SAB_NAME, :NEW.SORT, 'UPDATE', SYSDATE, USER, :NEW.ID_GROUP_SAB, :NEW.SAB_NAME, :NEW.SORT);
  ELSIF DELETING
  THEN
    INSERT INTO PMAC.HISTORY_GROUP_SAB (
      OLD_ID_GROUP_SAB, OLD_SAB_NAME, OLD_SORT, ACTION, DATE_ACTION, USER_ACTION
    )
    VALUES (:OLD.ID_GROUP_SAB, :OLD.SAB_NAME, :OLD.SORT, 'DELETE', SYSDATE, USER);
  END IF;
END;
/

ALTER TRIGGER PMAC.TRG_HISTORY_GROUP_SAB DISABLE;
/

--
-- Создать триггер "PMAC"."TRG_HISTORY_GROUP_MAIN"
--
CREATE TRIGGER PMAC.TRG_HISTORY_GROUP_MAIN
  AFTER INSERT OR UPDATE OR DELETE
  ON PMAC.TAB_GROUP_MAIN
  FOR EACH ROW
BEGIN
  IF INSERTING
  THEN
    INSERT INTO PMAC.HISTORY_GROUP_MAIN (
      ACTION, DATE_ACTION, USER_ACTION, NEW_ID_GROUP_MAIN, NEW_MAIN_NAME, NEW_SORT
    )
    VALUES ('INSERT', SYSDATE, USER, :NEW.ID_GROUP_MAIN, :NEW.MAIN_NAME, :NEW.SORT);
  ELSIF UPDATING
  THEN
    INSERT INTO PMAC.HISTORY_GROUP_MAIN (
      OLD_ID_GROUP_MAIN, OLD_MAIN_NAME, OLD_SORT, ACTION, DATE_ACTION, USER_ACTION, NEW_ID_GROUP_MAIN, NEW_MAIN_NAME, NEW_SORT
    )
    VALUES (:OLD.ID_GROUP_MAIN, :OLD.MAIN_NAME, :OLD.SORT, 'UPDATE', SYSDATE, USER, :NEW.ID_GROUP_MAIN, :NEW.MAIN_NAME, :NEW.SORT);
  ELSIF DELETING
  THEN
    INSERT INTO PMAC.HISTORY_GROUP_MAIN (
      OLD_ID_GROUP_MAIN, OLD_MAIN_NAME, OLD_SORT, ACTION, DATE_ACTION, USER_ACTION
    )
    VALUES (:OLD.ID_GROUP_MAIN, :OLD.MAIN_NAME, :OLD.SORT, 'DELETE', SYSDATE, USER);
  END IF;
END;
/

ALTER TRIGGER PMAC.TRG_HISTORY_GROUP_MAIN DISABLE;
/

--
-- Создать триггер "PMAC"."TRG_HISTORY_GROUP"
--
CREATE TRIGGER PMAC.TRG_HISTORY_GROUP
  AFTER INSERT OR UPDATE OR DELETE
  ON PMAC.TAB_GROUP
  FOR EACH ROW
BEGIN
  IF INSERTING
  THEN
    INSERT INTO PMAC.HISTORY_GROUP (
      ACTION, DATE_ACTION, USER_ACTION, NEW_ID_GROUP, NEW_ID_GROUP_MAIN, NEW_ID_GROUP_SAB, NEW_SHOW
    )
    VALUES ('INSERT', SYSDATE, USER, :NEW.ID_GROUP, :NEW.ID_GROUP_MAIN, :NEW.ID_GROUP_SAB, :NEW.SHOW);
  ELSIF UPDATING
  THEN
    INSERT INTO PMAC.HISTORY_GROUP (
      OLD_ID_GROUP, OLD_ID_GROUP_MAIN, OLD_ID_GROUP_SAB, OLD_SHOW, ACTION, DATE_ACTION, USER_ACTION, NEW_ID_GROUP, NEW_ID_GROUP_MAIN, NEW_ID_GROUP_SAB, NEW_SHOW
    )
    VALUES (:OLD.ID_GROUP, :OLD.ID_GROUP_MAIN, :OLD.ID_GROUP_SAB, :OLD.SHOW, 'UPDATE', SYSDATE, USER, :NEW.ID_GROUP, :NEW.ID_GROUP_MAIN, :NEW.ID_GROUP_SAB, :NEW.SHOW);
  ELSIF DELETING
  THEN
    INSERT INTO PMAC.HISTORY_GROUP (
      OLD_ID_GROUP, OLD_ID_GROUP_MAIN, OLD_ID_GROUP_SAB, OLD_SHOW, ACTION, DATE_ACTION, USER_ACTION
    )
    VALUES (:OLD.ID_GROUP, :OLD.ID_GROUP_MAIN, :OLD.ID_GROUP_SAB, :OLD.SHOW, 'DELETE', SYSDATE, USER);
  END IF;
END;
/

ALTER TRIGGER PMAC.TRG_HISTORY_GROUP DISABLE;
/

--
-- Создать триггер "PMAC"."TRG_GROUP_SAB_ID"
--
CREATE TRIGGER PMAC.TRG_GROUP_SAB_ID
  BEFORE INSERT
  ON PMAC.TAB_GROUP_SAB
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_GROUP_SAB.NEXTVAL
    INTO :new.ID_GROUP_SAB
    FROM DUAL;
END;
/

--
-- Создать триггер "PMAC"."TRG_GROUP_SAB_CREATE_GROUP"
--
CREATE TRIGGER PMAC.TRG_GROUP_SAB_CREATE_GROUP
  AFTER INSERT
  ON PMAC.TAB_GROUP_SAB
  FOR EACH ROW
BEGIN
  INSERT INTO TAB_GROUP (
    ID_GROUP_SAB, ID_GROUP_MAIN
  )
  SELECT :new.ID_GROUP_SAB,
  TGM.ID_GROUP_MAIN
  FROM TAB_GROUP_MAIN TGM;
END;
/

--
-- Создать триггер "PMAC"."TRG_GROUP_MAIN_ID"
--
CREATE TRIGGER PMAC.TRG_GROUP_MAIN_ID
  BEFORE INSERT
  ON PMAC.TAB_GROUP_MAIN
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_GROUP_MAIN.NEXTVAL
    INTO :new.ID_GROUP_MAIN
    FROM DUAL;


END;
/

--
-- Создать триггер "PMAC"."TRG_GROUP_MAIN_CREATE_GROUP"
--
CREATE TRIGGER PMAC.TRG_GROUP_MAIN_CREATE_GROUP
  AFTER INSERT
  ON PMAC.TAB_GROUP_MAIN
  FOR EACH ROW
BEGIN
  INSERT INTO TAB_GROUP (
    ID_GROUP_MAIN, ID_GROUP_SAB
  )
  SELECT :new.ID_GROUP_MAIN,
  TGS.ID_GROUP_SAB
  FROM TAB_GROUP_SAB TGS;

  INSERT INTO TAB_STIMUL_DEF (
    ID_TAB_GROUP_MAIN
  )
  VALUES (:new.ID_GROUP_MAIN);
END;
/

--
-- Создать триггер "PMAC"."TRG_GROUP_ID"
--
CREATE TRIGGER PMAC.TRG_GROUP_ID
  BEFORE INSERT
  ON PMAC.TAB_GROUP
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_GROUP.NEXTVAL
    INTO :new.ID_GROUP
    FROM DUAL D;
END;
/

--
-- Создать триггер "PMAC"."TRG_COMPANY_SELLER"
--
CREATE TRIGGER PMAC.TRG_COMPANY_SELLER
  BEFORE INSERT
  ON PMAC.TAB_COMPANY_SELLER
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_COMPANY_SELLER.NEXTVAL
    INTO :new.ID_SELLER
    FROM DUAL D;
END;
/

--
-- Создать триггер "PMAC"."TRG_CLOSED_PAYMENTS"
--
CREATE TRIGGER PMAC.TRG_CLOSED_PAYMENTS
  FOR UPDATE
  ON PMAC.TAB_PAYMENTS
COMPOUND TRIGGER
  VAR_ID_COMPANY              NUMBER;
  VAR_CASH_USD                NUMBER;
  VAR_PRICE                   NUMBER;
  VAR_SUM_LAST_OPERATION      NUMBER;
  VAR_ID_OPERATION            NUMBER;
  VAR_ID_PAYMENT              NUMBER;
  VAR_LAST_ID_OPERATION       NUMBER;
  VAR_COUNT_DAY               NUMBER;
  VAR_ID_CATEGORY             NUMBER;
  VAR_UPDATING                BOOLEAN;
  VAR_CASH_USD_NEXT           NUMBER;
  VAR_SUM_LAST_OPERATION_NEXT NUMBER;
  VAR_LAST_ID_OPERATION_NEXT  NUMBER;
BEFORE EACH ROW IS BEGIN


  IF :NEW.CLOSED = 1
    AND :OLD.CLOSED = 0
  THEN
    VAR_ID_COMPANY := :NEW.ID_COMPANY;
    VAR_ID_PAYMENT := :NEW.ID;
    VAR_UPDATING := TRUE;
  END IF;
END BEFORE EACH ROW;

AFTER STATEMENT IS
BEGIN
  IF VAR_UPDATING
  THEN
    LOOP
      SELECT NVL(SUM(TP1.CASH_USD) - PROPLACHINUE.PRICE + VOZVRATI.PRICE, 0)
        INTO VAR_CASH_USD
        FROM TAB_PAYMENTS TP1,
             (SELECT NVL(SUM(TOP.PRICE * TOP.QTY * DECODE(TOP.DISCOUNT, 0, 1, TOP.DISCOUNT * 0.01)), 0) PRICE
                 FROM TAB_OPERATION OP
                   JOIN TAB_OPERATION_PRODUCT TOP
                     ON OP.ID_OPERATION = TOP.ID_OPERATION
                   JOIN TAB_PAID TP
                     ON TP.ID_OPERATION = OP.ID_OPERATION
                 WHERE OP.ID_COMPANY = VAR_ID_COMPANY) PROPLACHINUE,
             (SELECT NVL(SUM(TOP.PRICE), 0) PRICE
                 FROM TAB_OPERATION_PRODUCT TOP
                   JOIN TAB_OPERATION OP
                     ON OP.ID_OPERATION = TOP.ID_OPERATION
                 WHERE OP.OPERATION_ID_TYPE = 0
                   AND OP.ID_COMPANY = VAR_ID_COMPANY) VOZVRATI
        WHERE TP1.ID_COMPANY = VAR_ID_COMPANY
        GROUP BY PROPLACHINUE.PRICE,
                 VOZVRATI.PRICE;

      SELECT SUM(TOP.PRICE)
        INTO VAR_PRICE
        FROM TAB_OPERATION_PRODUCT TOP
          JOIN TAB_OPERATION OP
            ON OP.ID_OPERATION = TOP.ID_OPERATION
        WHERE OP.ID_COMPANY = VAR_ID_COMPANY;


      SELECT NVL(SUM(TOP.PRICE * TOP.QTY * DECODE(TOP.DISCOUNT, 0, 1, TOP.DISCOUNT * 0.01)), 0)
        INTO VAR_SUM_LAST_OPERATION
        FROM TAB_OPERATION OP
          JOIN TAB_OPERATION_PRODUCT TOP
            ON OP.ID_OPERATION = TOP.ID_OPERATION
        WHERE OP.OPERATION_DATE = (SELECT MIN(OP1.OPERATION_DATE)
              FROM TAB_OPERATION OP1
                LEFT JOIN TAB_PAID TP
                  ON TP.ID_OPERATION = OP1.ID_OPERATION
                JOIN TAB_COMPANY TC
                  ON OP1.ID_COMPANY = tc.ID_COMPANY
              WHERE OP1.ID_COMPANY = VAR_ID_COMPANY
                AND TP.ID_OPERATION IS NULL
                AND (OP1.STATUS = 22
                AND TC.ID_TAB_TYPE IN (1, 5, 8)
                OR OP1.STATUS = 41
                AND TC.ID_TAB_TYPE IN (3, 6)))
          AND OP.ID_COMPANY = VAR_ID_COMPANY;

      EXIT WHEN VAR_CASH_USD < VAR_SUM_LAST_OPERATION;


      SELECT MAX(OP.ID_OPERATION)
        INTO VAR_LAST_ID_OPERATION
        FROM TAB_OPERATION OP
        WHERE OP.OPERATION_DATE = (SELECT MIN(OP1.OPERATION_DATE)
              FROM TAB_OPERATION OP1
                LEFT JOIN TAB_PAID TP
                  ON TP.ID_OPERATION = OP1.ID_OPERATION
                JOIN TAB_COMPANY TC
                  ON OP1.ID_COMPANY = TC.ID_COMPANY
              WHERE OP1.ID_COMPANY = VAR_ID_COMPANY
                AND TP.ID_OPERATION IS NULL
                AND (OP1.STATUS = 22
                AND TC.ID_TAB_TYPE IN (1, 5, 8)
                OR OP1.STATUS = 41
                AND TC.ID_TAB_TYPE IN (3, 6)))
          AND OP.ID_COMPANY = VAR_ID_COMPANY;

      EXIT WHEN VAR_LAST_ID_OPERATION IS NULL;

      SELECT TRUNC(MAX(TP1.DATE_CLOSED) - MIN(OP1.OPERATION_DATE))
        INTO VAR_COUNT_DAY
        FROM TAB_OPERATION OP1
               LEFT JOIN TAB_PAID TP
                 ON TP.ID_OPERATION = OP1.ID_OPERATION,
             TAB_PAYMENTS TP1
        WHERE OP1.ID_COMPANY = VAR_ID_COMPANY
          AND TP.ID_OPERATION IS NULL;


      SELECT MAX(CASE WHEN VAR_COUNT_DAY = 2 THEN 4 WHEN VAR_COUNT_DAY = 90 THEN 1 WHEN VAR_COUNT_DAY = 150 THEN 2 ELSE 10 END)
        INTO VAR_ID_CATEGORY
        FROM TAB_PAID_STATUS_CATEGORY;



      INSERT INTO TAB_PAID (
        ID_OPERATION, ID_CATEGORY, ID_PAYMENT, DATE_PAYMENT
      )
      VALUES (VAR_LAST_ID_OPERATION, VAR_ID_CATEGORY, VAR_ID_PAYMENT, SYSDATE);

    END LOOP;



  END IF;


END AFTER STATEMENT;
END;
/

--
-- Создать триггер "PMAC"."TRG_CHECK_OPERATION_MAG"
--
CREATE TRIGGER PMAC.TRG_CHECK_OPERATION_MAG
  BEFORE INSERT OR UPDATE
  ON PMAC.TAB_CASHLESS
  FOR EACH ROW
BEGIN
  IF :NEW.CHECK_OPERATION_MAG = 1
    AND :NEW.ID_TYPE <> 6
  THEN
    INSERT INTO TAB_OPERATION_MAG (
      ID_COST_CASHLESS, ID_TYPE, SUMM_PLUS, SUMM_MINUS, DISCRIPTION, CHECK_CASHLESS, ID_COURSE, DATE_CREATE, DATE_OPERATION, ID_COMPANY, NAME_USER, ID_SELLER
    )
    VALUES (:old.ID_COST, :new.ID_TYPE, :new.SUMM_PLUS, :new.SUMM_MINUS, :new.DISCRIPTION, 1, FN_COURSE_OPERATION_MAG(1), SYSDATE, SYSDATE, :new.ID_COMPANY, 'PMAC', :old.ID_SELLER);
  END IF;
  IF :NEW.CHECK_OPERATION_MAG = 0
    AND :NEW.ID_TYPE <> 6
  THEN
    DELETE TAB_OPERATION_MAG
      WHERE ID_COST_CASHLESS = :NEW.ID_COST;
  END IF;
END;
/

--
-- Создать триггер "PMAC"."TRG_ADVENT_STORAGE"
--
CREATE TRIGGER PMAC.TRG_ADVENT_STORAGE
  AFTER INSERT OR UPDATE OF STATUS
  ON PMAC.TAB_OPERATION
  FOR EACH ROW
BEGIN
  IF :NEW.STATUS = 13
  THEN
    INSERT INTO TAB_ADVENT_OPERATION_STORAGE (
      ID_OPERATION, ID_STORAGE
    )
    SELECT TOP.ID_OPERATION,
    TOP.ID_COMPANY
    FROM TAB_OPERATION_PRODUCT TOP
    WHERE TOP.ID_OPERATION = :OLD.ID_OPERATION
    GROUP BY TOP.ID_COMPANY,
    TOP.ID_OPERATION;
  END IF;


  IF (INSERTING
    AND :old.STATUS = 30)
  THEN
    INSERT INTO TAB_ADVENT_OPERATION_STORAGE (
      ID_OPERATION, ID_STORAGE
    )
    SELECT TOP.ID_OPERATION,
    TOP.ID_COMPANY
    FROM TAB_OPERATION_PRODUCT TOP
    WHERE TOP.ID_OPERATION = :old.ID_OPERATION
    GROUP BY TOP.ID_COMPANY,
    TOP.ID_OPERATION;
  END IF;

END;
/

ALTER TRIGGER PMAC.TRG_ADVENT_STORAGE DISABLE;
/

--
-- Создать триггер "PMAC"."TRG_ADVENT_OPERATION_CHECK"
--
CREATE TRIGGER PMAC.TRG_ADVENT_OPERATION_CHECK
  FOR UPDATE OF CHEK
  ON PMAC.TAB_ADVENT_OPERATION_STORAGE
COMPOUND TRIGGER
  VAR_UPDATING    BOOLEAN;
  VAR_CHEKING     NUMBER;
  VAR_IDOPERATION NUMBER;

BEFORE EACH ROW IS BEGIN

  IF :NEW.CHEK = 1
    AND :OLD.CHEK = 0
  THEN
    VAR_IDOPERATION := :NEW.ID_OPERATION;

    VAR_UPDATING := TRUE;
  END IF;
END BEFORE EACH ROW;

AFTER STATEMENT IS
BEGIN
  IF VAR_UPDATING
  THEN
    SELECT MIN(TAOS.CHEK)
      INTO VAR_CHEKING
      FROM TAB_ADVENT_OPERATION_STORAGE TAOS
      WHERE TAOS.ID_OPERATION = VAR_IDOPERATION
      GROUP BY TAOS.ID_OPERATION;

    IF VAR_CHEKING = 1
    THEN
      UPDATE TAB_OPERATION O
        SET STATUS = 14
        WHERE O.ID_OPERATION = VAR_IDOPERATION;
    END IF;
  END IF;
END AFTER STATEMENT;
END;
/

ALTER TRIGGER PMAC.TRG_ADVENT_OPERATION_CHECK DISABLE;
/

--
-- Создать триггер "PMAC"."TRG_ADD_USERS"
--
CREATE TRIGGER PMAC.TRG_ADD_USERS
  BEFORE CREATE
    ON DATABASE
BEGIN
  IF ((ora_dict_obj_type = 'USER')
    AND (ora_sysevent = 'CREATE'))
  THEN
    INSERT INTO PMAC.TAB_USERS (
      NAME
    )
    VALUES (ora_dict_obj_name);
  END IF;
END;
/

--
-- Создать триггер "PMAC"."TGR_STIM_ADD"
--
CREATE TRIGGER PMAC.TGR_STIM_ADD
  BEFORE INSERT
  ON PMAC.TAB_STIMULATION_PAYOUT
  FOR EACH ROW
DECLARE
  IDCOMPANY NUMBER;
  MAINGROUP NUMBER;
  IDGROUP   NUMBER;
BEGIN
  SELECT "to".id_company
    INTO IDCOMPANY
    FROM TAB_OPERATION "to"
    WHERE ID_OPERATION = :new.ID_OPERATION;

  SELECT TP.ID_GROUP
    INTO IDGROUP
    FROM TAB_PRODUCT TP
    WHERE TP.ID_product = :NEW.ID_PRODUCT;

  SELECT TG.ID_GROUP_MAIN
    INTO MAINGROUP
    FROM TAB_GROUP TG
      JOIN TAB_GROUP_MAIN TGM
        ON TG.ID_GROUP_MAIN = TGM.ID_GROUP_MAIN
    WHERE TG.ID_GROUP = IDGROUP;

  SELECT STIMUL
    INTO :NEW.STIMUL
    FROM TAB_COMPANY_GROUP TCG
    WHERE ID_TAB_GROUP_MAIN = MAINGROUP
      AND TCG.ID_TAB_COMPANY = IDCOMPANY;

  SELECT STIMUL_TYPE
    INTO :NEW.STIMUL_TYPE
    FROM TAB_COMPANY_GROUP TCG
    WHERE ID_TAB_GROUP_MAIN = MAINGROUP
      AND TCG.ID_TAB_COMPANY = IDCOMPANY;

END;
/

--
-- Создать триггер "PMAC"."TGR_OPERATION_PRODUCT_RESERVE"
--
CREATE TRIGGER PMAC.TGR_OPERATION_PRODUCT_RESERVE
FOR INSERT OR UPDATE OF STATUS ON PMAC.TAB_OPERATION
COMPOUND TRIGGER
  VAR_ID_OPERATION NUMBER;

AFTER EACH ROW IS BEGIN

  VAR_ID_OPERATION := :NEW.ID_OPERATION;

END AFTER EACH ROW;

AFTER STATEMENT IS
BEGIN
  PRC_RESERVE(VAR_ID_OPERATION);
END AFTER STATEMENT;
END;
/

--
-- Создать триггер "PMAC"."TGR_ID_OPERATION_PRODUCT"
--
CREATE TRIGGER PMAC.TGR_ID_OPERATION_PRODUCT
  BEFORE INSERT
  ON PMAC.TAB_OPERATION_PRODUCT
  FOR EACH ROW
BEGIN
  SELECT SEQ_ID_OPERATION_PRODUCT.NEXTVAL
    INTO :new.ID
    FROM dual;

  IF FN_OLD(:NEW.ID_PRODUCT, :NEW.ID_OPERATION, :NEW.ID)
  THEN
    INSERT INTO TAB_OPERATION_PRODUCT_CHECK
    VALUES (:NEW.ID_OPERATION, :NEW.ID_PRODUCT, :NEW.ID);
  END IF;
END;
/

COMMIT;